from compute import (cuboids_bounds, axis_signs_visible, intersect_ray_cuboid_face, magnitude_vector, subtract_arrays, cuboid_transformed, cuboid_new, matrix_identity, product_matrices, matrix_placement, new_id, filename_type)

from standard import in_array_string

# thing has children. children are thing + geometry.
# rotates is an array of 2 rotations. Or empty list if no rotations.
# position and rotates are relative to current context.
# bounds are used for collision.
(object thing) thing_new(string id, string type, array position, array rotates, array children, object geometry, object bounds):
    thing = {
        "id": id,
        "type": type,
        "position": position,
        "rotates": rotates,
        "children": children,
        "geometry": geometry,
        "bounds": bounds,
        "mass": 1,
        "force": [0.0, 0.0, 0.0],
        "velocity": [0.0, 0.0, 0.0],
        "position_delta": [0.0, 0.0, 0.0],
        "animate_start": 0
    }

(object thing) thing_blank(string id, string type):
    thing = thing_new(id, type, [0.0, 0.0, 0.0], [], [], null, null)

() thing_set_children(object thing, object things):
    new_children = []
    for child in thing.children:
        child_thing = things{child.name}
        append(new_children, child_thing)
    thing.children = new_children


(array thing) thing_read(object state, string filename):
    text = null
    file_read(join([state.things_dir, filename], "/"), text)
    (name, ext) = filename_type(filename)
    print(["thing_load opening", name, text])
    #TODO: incomplete
    map = from_json(text)
    children = []
    geometry = null
    if in_array_string(keys(map), "children_names"):
        child_names = map.children_names
        for child_name in child_names:
            child = {"name": child_name}
            append(children, child)
    else:
        geometry_name = map.geometry_name
        geometry = state.geometries{geometry_name}
    thing = thing_new(new_id(state), "", [0.0,0.0,0.0], [], children, geometry, null)
    update(thing, map)
    if in_array_string(keys(thing), "name") == false:
        thing.name = name

# state must have two things:
# things_dir
# geometries map
(object thing) thing_load(object state, string name):
    text = null
    file_read(join([state.things_dir, name], "/"), text)
    print(["thing_load opening", name, text])
    map = from_json(text)
    children = []
    geometry = null
    if in_array_string(keys(map), "children_names"):
        child_names = map.children_names
        for child_name in child_names:
            child = thing_load(state, child_name)
            append(children, child)
    else:
        geometry_name = map.geometry_names[map.geometry_index]
        geometry = state.geometries{geometry_name}
    thing = thing_new(new_id(state), "", [0.0,0.0,0.0], [], children, geometry, null)
    update(thing, map)

# the thing's current placement is considered the origin.
() thing_set_bounds_unused(object thing, array offset):
    matrix = matrix_placement(thing.position, thing.rotates)
    new_offset = product_matrices(offset, matrix)
    thing.offset = new_offset
    if length(thing.geometry) > 0:
        #bounds = cubes_bounds(thing.cubes)
        bounds = thing.bounds
        (new_position, new_size) = cuboid_transformed(new_offset, bounds.position, bounds.size)
        thing.bounds = cuboid_new(new_position, new_size)
    else:
        cuboids = []
        for child in thing.children:
            thing_set_bounds(child, new_offset)
            append(cuboids, child.bounds)
        (position, size) = cuboids_bounds(cuboids)
        thing.bounds = cuboid_new(position, size)


# find a child thing that intersects with the ray defined by origin and direction.
# faces is a array of face objects that should be checked.
# hit_thing is null if nothing was found.
# thing.bounds must not be null.
# offset is a matrix
(object hit_thing, object hit_face, array hit_point) intersect_ray_bounds_unused(array origin, array direction, object thing, array faces, array offset):
    # first, does ray cross the bounding box?
    hit_point = null
    matrix = matrix_placement(thing.position, thing.rotates)
    new_offset = product_matrices(offset, matrix)
    (new_position, new_size) = cuboid_transformed(new_offset, thing.bounds.position, bounds.size)
    for face in faces:
        hit_point = intersect_ray_cuboid_face(origin, direction, thing.bounds.position, thing.bounds.size, face.axis, face.sign)
        if hit_point != null:
            hit_thing = thing
            hit_face = face
            break

    if hit_point == null:
        hit_thing = null
        return
    else:
        if length(thing.cubes) == 0:
            for child in thing.children:
                (hit_thing, hit_face, hit_point) = intersect_ray_bounds(origin, direction, child, faces)
                if hit_thing != null:
                    return
            hit_thing = null
            return
        else:
            # reached bottom. hit_thing and hit_face already set.
            return

# intersect an array with a thing. Returns the thing it
# intersected with. hit_thing is null if no cubes hit the ray.
# return: indices ( ), hit_thing, face (Face)
# array is matrix
(object hit_thing, object hit_face, array hit_offset, number hit_distance) intersect_ray_thing(array origin, array direction, object thing):
    hit_thing = null
    faces = axis_signs_visible(direction)
    # find the cube that has this point
    #print(thing)
    #print(faces)
    #print(["intersect_ray origin ", origin])
    #print(["intersect_ray direction ", direction])
    #if thing.bounds == null:
        #thing_set_bounds(thing, matrix_identity())
        #print(["thing_bounds ", thing.bounds])
    #(hit_thing, bounds_face, hit_point) = intersect_ray_bounds(origin, direction, thing, faces, matrix_identity())
    #if hit_thing == null:
    #    print(["intersect_ray_thing null "])
    #    return
    #print(["intersect_ray point ", hit_point, bounds_face])

    (hit_thing, hit_face, hit_offset, hit_distance) = intersect_ray_thing_faces(origin, direction, thing, matrix_identity(), faces)
    #if hit_cube == null:
    #    hit_thing = null
    #print(["intersect_ray hit_cube position ", hit_cube.position])

# faces are visible faces as ray hits from outside.
# hit_cube is null if none of the voxels hit
# TODO: perform breadth first search? No, since only one of the faces should intersect the ray
(object hit_thing, object hit_face, array hit_offset, number min_distance) intersect_ray_thing_faces(array origin, array direction, array thing, array offset, array faces):
    hit_thing = null
    min_distance = 0
    matrix = matrix_placement(thing.position, thing.rotates)
    new_offset = product_matrices(offset, matrix)
    if thing.bounds == null:
        for child in thing.children:
            (child_hit_thing, child_hit_face, child_hit_offset, child_min_distance) =  intersect_ray_thing_faces(origin, direction, child, new_offset, faces)
            if child_hit_thing != null:
                if hit_thing == null:
                    hit_thing = child_hit_thing
                    hit_face = child_hit_face
                    min_distance = child_min_distance
                    hit_offset = child_hit_offset
                else:
                    if child_min_distance < min_distance:
                        hit_thing = child_hit_thing
                        hit_face = child_hit_face
                        min_distance = child_min_distance
                        hit_offset = child_hit_offset
    else:
        bounds = thing.bounds
        (new_position, new_size) = cuboid_transformed(new_offset, bounds.position, bounds.size)
        for face in faces:
            intersect_point = intersect_ray_cuboid_face(origin, direction, new_position, new_size, face.axis, face.sign)
            if intersect_point != null:
                min_distance = magnitude_vector(subtract_arrays(intersect_point, origin))
                hit_thing = thing
                hit_face = face
                hit_offset = new_offset
                return

# 3 classes of things:
# 1. won't ever collide with anything. leave it from comparison.
# 2. can collide with things, but doesn't move.
# 3. can collide with things and moves.
() collide():
    return
